<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaoHou Blog</title>
  
  <subtitle>You&#39;re Welcome</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.xiaohoutongxue.cn/"/>
  <updated>2018-05-03T05:48:41.347Z</updated>
  <id>http://www.xiaohoutongxue.cn/</id>
  
  <author>
    <name>xiaoHou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android压缩图片并保存到相册</title>
    <link href="http://www.xiaohoutongxue.cn/2018/05/03/Android/Android%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E7%9B%B8%E5%86%8C/"/>
    <id>http://www.xiaohoutongxue.cn/2018/05/03/Android/Android保存图片到相册/</id>
    <published>2018-05-03T05:18:07.000Z</published>
    <updated>2018-05-03T05:48:41.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要描述怎么压缩图片并保存到相册，保存的图片文件能够立刻在系统相册和图库中找到。</p></blockquote><p><img src="http://p6urtncv1.bkt.clouddn.com/look_img.gif" alt="查看并保存图片"></p><h2 id="主要步骤："><a href="#主要步骤：" class="headerlink" title="主要步骤："></a><strong>主要步骤：</strong></h2><h3 id="使用Glide设置图片到控件"><a href="#使用Glide设置图片到控件" class="headerlink" title="使用Glide设置图片到控件"></a>使用Glide设置图片到控件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(mContext).load(Constant.IMG_LOOK_URL).apply(<span class="keyword">new</span> RequestOptions().placeholder(R.drawable.touxiang).override(ScreenUtils.getScreenWidth(), <span class="number">500</span>)).into(imgLookImg);</span><br></pre></td></tr></table></figure><h3 id="将ImageView转换成Bitmap"><a href="#将ImageView转换成Bitmap" class="headerlink" title="将ImageView转换成Bitmap"></a>将ImageView转换成Bitmap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bitmap image = ((BitmapDrawable) imgLookImg.getDrawable()).getBitmap();</span><br></pre></td></tr></table></figure><h3 id="确定保存路径"><a href="#确定保存路径" class="headerlink" title="确定保存路径"></a>确定保存路径</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + <span class="string">"sendmessage"</span>;</span><br><span class="line">      File file = <span class="keyword">new</span> File(path);</span><br><span class="line">      <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">          <span class="keyword">return</span> path;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> path;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在Android中文件存储路径包括内部存储和外部存储两种类型。<br>对内部存储，当一个app被安装到手机后，Android系统会在内部存储的/data/data/目录下创建一个以包名称命名的文件夹。例如/data/data/com.sohu.inputmethod.sogou/。一个应用对内部存储的所有访问都被限制在这个文件夹中，也就是说Android应用只能在该目录中读取，创建，修改文件。对该目录之外的其他内部存储中的目录都没有任何操作的权限。因此，如果将图片保存在内部存储中，只能被应用自身读取，其他应用均无法读取。如果需要让系统图库，相册或其他应用能够找到保存的图片，必须将图片保存到外部存储中。</p><p>对外部存储，当一个app被安装到手机后，Android系统会在外部存储的/Android/data/目录下创建一个以包名命名的文件夹（这里第一个/不是根路径，而是相对外部存储所挂载路径的相对路径）。例如/storage/emulated/0/Android/data/com.sohu.inputmethod/。这个路径同样只能被应用自身读取，其他应用不能访问。因此，也不能将图片保存在这个目录中。</p><p>除外部存储的/Android目录之外的其他目录一般都是可以被其他应用访问的。目前，大多数应用都会在外部存储的根路径下建立一个类似包名的多层目录，以存储需要共享的文件。例如/storage/emulated/0/sogou/image/。还需要注意的是，很多查看图片的应用都支持按照文件夹来查看图片。如果将图片所在的文件夹取名为image，photo之类的，就无法和其他文件夹区分开，用户也不能识别该文件夹的用途。因此最好取一个有区分度的文件夹名字，例如百度贴吧就保存在/tieba目录，微信是保存在/tencent/MicroMsg/WeiXin目录。<br>由于Android系统的碎片化问题，不同设备上外部存储的路径很可能会不同，因此，不能直接使用/storage/emulated/0/作为外部存储的根路径。</p><h3 id="获取外部存储权限"><a href="#获取外部存储权限" class="headerlink" title="获取外部存储权限"></a>获取外部存储权限</h3><p>由于需要在外部存储中写文件，需要在AndroidManifest.xml中增加如下的权限声明。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="确定文件名"><a href="#确定文件名" class="headerlink" title="确定文件名"></a>确定文件名</h3><p>  保存的图片文件名可以由应用根据自身需要自行确定，一般来说需要有一个命名规则，然后根据命名规则计算得到文件名。<br>  这里列举几种常见的命名规则。</p><ul><li>随机命名<br>这种命名规则是随机生成一个字符串或一组数字来对图片命名。<br>字符串可以通过UUID来生成，数字可以通过Random()类来生成，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过UUID生成字符串文件名  </span></span><br><span class="line">String fileName1 = UUID.randomUUID().toString();  </span><br><span class="line"><span class="comment">//通过Random()类生成数组命名  </span></span><br><span class="line">Random random = <span class="keyword">new</span> Random();  </span><br><span class="line">String fileName2 = String.valueOf(random.nextInt(Integer.MAX_VALUE));</span><br></pre></td></tr></table></figure></li></ul><p>这种命名规则是按照数字从小到大的顺序来对图片命名。 </p><p>在程序启动时先获取图片文件名中当前最大数字的文件名，之后每保存一张图片就将数字加1即可。</p><ul><li>时间命名<br>这种命名规则是根据保存图片的当前系统时间来对图片命名。<br>系统时间可以通过System.currentTimeMillis()来获取，不过System.currentTimeMillis()获取到的时间是一个long型的整数，如果用它做文件名，无法通过文件名直接看出文件的具体保存时间。可以通过SimpleDateFormat先对当前时间做格式化，然后再将其作为文件名来使用。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar now = <span class="keyword">new</span> GregorianCalendar();  </span><br><span class="line">SimpleDateFormat simpleDate = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddHHmmss"</span>, Locale.getDefault());  </span><br><span class="line">String fileName = simpleDate.format(now.getTime());</span><br></pre></td></tr></table></figure></li></ul><p>使用这种命名规则来命名需要注意的是同一秒钟可能会有多张图片需要保存，在得到当前系统时间对应的文件名后，需要判断该文件是否存在。如果文件已经存在，需要重新生成文件名。重新生成的文件名可以在之前的文件名后加上一个随机数后缀，或者是用毫秒数做后缀。</p><ul><li>文件URL命名<br>每张网络图片都有一个对应的图片URL，可以根据图片的URL来对图片命名。<br>不过URL中会包含一些不能用作文件名的特殊字符，此外直接用URL来命名可能会带来安全问题。为了避免这两个问题，可以将图片URL的MD5值作为文件名来使用。由于MD5是不可逆的，也就无法通过MD5值反向得到图片URL，同时MD5值对应的字符串只包含[0-9A-Z]，不包含特殊字符，可是作为文件名使用。<br>由于每张图片的URL是唯一的，其对应的文件名也就是唯一的。如果需要每张网络图片只能生成一个文件，不允许保存为多份拷贝，可以用这种命名规则。在得到URL对应的文件名后，先判断文件是否已经存在，如果已经存在，直接覆盖或不处理。<h3 id="保存到文件中"><a href="#保存到文件中" class="headerlink" title="保存到文件中"></a>保存到文件中</h3>保存图片文件时，通过Bitmap的compress()方法将Bitmap对象压缩到一个文件输出流中，然后flush()即可。示例如下。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">saveImgToGallery</span><span class="params">(Context context, Bitmap bitmap)</span></span>&#123;</span><br><span class="line">       File appDir = <span class="keyword">new</span> File(getPath());</span><br><span class="line">       <span class="keyword">if</span> (!appDir.exists())&#123;</span><br><span class="line">           appDir.mkdir();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//设置文件名</span></span><br><span class="line">       String fileName = System.currentTimeMillis()+<span class="string">".jpg"</span>;</span><br><span class="line">       File file = <span class="keyword">new</span> File(appDir,fileName);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">           <span class="comment">//通过io流来压缩保存图片</span></span><br><span class="line">           <span class="keyword">boolean</span> isSuccess = bitmap.compress(Bitmap.CompressFormat.JPEG,<span class="number">60</span>,fileOutputStream);</span><br><span class="line">           fileOutputStream.flush();</span><br><span class="line">           fileOutputStream.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="发送广播，通知系统扫描保存后的文件"><a href="#发送广播，通知系统扫描保存后的文件" class="headerlink" title="发送广播，通知系统扫描保存后的文件"></a>发送广播，通知系统扫描保存后的文件</h3><p>至此，已经实现将Bitmap对象保存成外部存储中的一个jpg格式的文件。但此时该文件只是保存在外部存储的一个目录中，必须进入其所在的目录中才可以看到。在系统图库，相册和其他应用中无法看到新建的图片文件。为了让其他应用能够知道图片文件被创建，必须通知MediaProvider服务将新建的文件添加到图片数据库中。</p><p>Android系统中常驻一个MediaProvider服务，对应的进程名为android.process.media，此服务用来管理本机上的媒体文件，提供媒体管理服务。在系统开机或者收到外部存储的挂载消息后，MediaProvider会调用MediaScanner，MediaScanner会扫描外部存储中的所有文件，根据文件类型的后缀将文件信息保存到对应的数据库中，供其他APP使用。</p><p>MediaScannerReceiver是一个广播接收者，当它接收到特定的广播请求后，就会去扫描指定的文件，并根据文件信息将其添加到数据库中。当图片文件被创建后，就可以发送广播给MediaScannerReceiver，通知其扫描新建的图片文件。示例如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通知更新数据库</span></span><br><span class="line">Uri uri =  Uri.fromFile(file);</span><br><span class="line">context.sendBroadcast(<span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri));</span><br></pre></td></tr></table></figure></p><h3 id="图片的异步保存"><a href="#图片的异步保存" class="headerlink" title="图片的异步保存"></a>图片的异步保存</h3><p>保存图片文件时，如果图片很大，或需要同时保存多张图片时，就需要较多的时间。为了避免阻塞UI线程，出现帧率下降或ANR，通常需要将图片保存操作放到线程中去执行。当图片保存完毕后通过sendMessage()方法通知UI线程保存结果。<br>将图片保存放到后台线程去执行需要增加一些同步机制避免一些多线程问题。例如有两张图片需要保存，分别放到两个线程中去执行，保存图片时文件名以数字顺序增加。第一个线程选中文件名为125.jpg，但此时文件还未创建，第二个线程判断125.jpg不存在，于是也选取125.jpg作为文件名，两张图片就保存到同一个文件中了。</p><h3 id="具体源码"><a href="#具体源码" class="headerlink" title="具体源码"></a>具体源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建时间: 2018/5/3</span></span><br><span class="line"><span class="comment"> * 作者: xiaoHou</span></span><br><span class="line"><span class="comment"> * E-mail: 605322850@qq.com</span></span><br><span class="line"><span class="comment"> * Blog: www.xiaohoutongxue.cn</span></span><br><span class="line"><span class="comment"> * 描述: ImageCacheUtlis 图片缓存到本地</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageCacheUtlis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">saveImgToGallery</span><span class="params">(Context context, Bitmap bitmap)</span></span>&#123;</span><br><span class="line">        File appDir = <span class="keyword">new</span> File(getPath());</span><br><span class="line">        <span class="keyword">if</span> (!appDir.exists())&#123;</span><br><span class="line">            appDir.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置文件名</span></span><br><span class="line">        String fileName = System.currentTimeMillis()+<span class="string">".jpg"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(appDir,fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            <span class="comment">//通过io流来压缩保存图片</span></span><br><span class="line">            <span class="keyword">boolean</span> isSuccess = bitmap.compress(Bitmap.CompressFormat.JPEG,<span class="number">60</span>,fileOutputStream);</span><br><span class="line">            fileOutputStream.flush();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">            <span class="comment">//通知更新数据库</span></span><br><span class="line">            Uri uri =  Uri.fromFile(file);</span><br><span class="line">            context.sendBroadcast(<span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri));</span><br><span class="line">            <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String path = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + <span class="string">"sendmessage"</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (file.mkdirs()) &#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要描述怎么压缩图片并保存到相册，保存的图片文件能够立刻在系统相册和图库中找到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://p6urtncv1.bkt.clouddn.com/look_img.gif&quot; alt
      
    
    </summary>
    
      <category term="Android" scheme="http://www.xiaohoutongxue.cn/categories/Android/"/>
    
    
      <category term="-图片保存" scheme="http://www.xiaohoutongxue.cn/tags/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Android设计模式(一)-六大原则及分类</title>
    <link href="http://www.xiaohoutongxue.cn/2018/04/24/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.xiaohoutongxue.cn/2018/04/24/Android设计模式/Android设计模式/</id>
    <published>2018-04-24T07:22:00.000Z</published>
    <updated>2018-04-25T04:59:20.691Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android进阶之光设计模式学习笔记，参考博客：<a href="https://blog.csdn.net/zhengzhb/article/category/926691/2" target="_blank" rel="noopener">https://blog.csdn.net/zhengzhb/article/category/926691/2</a></p></blockquote><h3 id="设计模式六大原则及其定义"><a href="#设计模式六大原则及其定义" class="headerlink" title="设计模式六大原则及其定义"></a><strong>设计模式六大原则及其定义</strong></h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><blockquote><p><strong>定义：就一个类而言应该只有一个能让他变化的原因</strong></p></blockquote><p>通俗点理解就是我们不能让一个类承担过多的职责。如果这个类承担过多的职责就大大真强其耦合度，其耦合度的增强着可以造成不必要的麻烦。</p><blockquote><p>比如有些Android开发者在Activity中写Bean文件、网络数据处理等等操作一个Activity有上千行代码Activity过于臃肿我们在版本维护时就比较麻烦而且也容易引起Activity各种变化。</p></blockquote><h4 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h4><blockquote><p><strong>定义：类、模块、函数等应该是可以拓展的但是是不能修改的</strong></p></blockquote><p>开放封闭原则有两个含义：</p><ul><li>对于拓展是开放的</li><li>对修改是封闭的</li></ul><p>于开发来说修改需求是常有的事，但是有新需求就要把类重新修改一变显然是不够明智的。    所以在我们设计程序时，面对需求的改变尽可能的保证相对稳定，尽量通过扩展的方式来实现变化，而不是修改原有代码。</p><blockquote><p>假如我们现在有一个列表，一开始查询功能过几天需要添加修改功能然后在过几天又于需要添加删除功能这个时候大多数人做法都是穿不同的值来控制来实现不同功能，然而如果又有需求需要修改我们则又要修改代码，然而我们使用开放封闭原则就是增加一个抽象类每次修改需求只需要添加一个功能子类实现其中方法即可。</p></blockquote><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><blockquote><p><strong>定义：子类可以扩展父类的功能，但不能改变父类原有的功能</strong></p></blockquote><p>里氏替换原则四层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格</li></ul><blockquote><p>例：现在我们需要完成两个数相减功能有类A来负责</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> a-b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        A a = <span class="keyword">new</span> A();  </span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));  </span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>100-50=50<br>100-80=20<br>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">funcB2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        B b = <span class="keyword">new</span> B();  </span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));   </span><br><span class="line">        System.out.println(<span class="string">"100+20+100="</span>+b.funcB2(<span class="number">100</span>, <span class="number">20</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类B完成后，运行结果：<br>100-80=180<br>100+20+100=220</p></blockquote><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><blockquote><p><strong>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</strong></p></blockquote><p> 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<br>依赖倒置原则的核心思想是<strong>面向接口编程</strong>，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。</p><blockquote><p>场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(Book book)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"妈妈开始讲故事"</span>);  </span><br><span class="line">        System.out.println(book.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Book());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"林书豪38+7领导尼克斯击败湖人……"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"林书豪17+9助尼克斯击败老鹰……"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"妈妈开始讲故事"</span>);  </span><br><span class="line">        System.out.println(reader.getContent());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();  </span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Book());  </span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Newspaper());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……</p></blockquote><p> 这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。<br>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递。<br>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li>使用继承时遵循里氏替换原则。</li></ul><p><strong>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</strong></p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><blockquote><p><strong>定义：一个对象应该对其他对象保持最少的了解。</strong></p></blockquote><p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。<br>通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。</p><blockquote><p>举一个栗子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。代码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//分公司</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getSubEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            SubEmployee subEmployee= <span class="keyword">new</span> SubEmployee();</span><br><span class="line">            subEmployee.setId(<span class="string">"分公司成员"</span>+i);</span><br><span class="line">            list.add(subEmployee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pintln</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list = getSubEmployee();</span><br><span class="line">        <span class="keyword">for</span> (SubEmployee subEmployee:list)&#123;</span><br><span class="line">            System.out.println(subEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 总公司</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Employee employee= <span class="keyword">new</span> Employee();</span><br><span class="line">            employee.setId(<span class="string">"总公司成员"</span>+i);</span><br><span class="line">            list.add(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pintln</span><span class="params">(SubCompanyManager subCompanyManager)</span></span>&#123;</span><br><span class="line">        subCompanyManager.pintln();</span><br><span class="line">        List&lt;Employee&gt; list = getEmployee();</span><br><span class="line">        <span class="keyword">for</span> (Employee subEmployee:list)&#123;</span><br><span class="line">            System.out.println(subEmployee.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg )</span></span>&#123;</span><br><span class="line">        CompanyManager companyManager = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">        companyManager.pintln(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><blockquote><p><strong>定义：客户端不应该依赖不需要的接口，一个类对另外一个类的依赖建立在接口上</strong></p></blockquote><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><blockquote><p>在举一个栗子：</p></blockquote><p><img src="http://p6urtncv1.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-1.png" alt=""></p><blockquote><p>这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。<br>如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图所示：</p></blockquote><p><img src="http://p6urtncv1.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99-2.png" alt=""></p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a><strong>设计模式分类</strong></h3><blockquote><p>GoF提出的设计模式一共分为23中，根据目的一共分为三大类</p></blockquote><p>1.创建型设计模式</p><ul><li>单利模式</li><li>工厂方法</li><li>抽象工厂模式</li><li>建造者模式</li><li>原型模式</li></ul><p>2.构造型设计模式</p><ul><li>适配器模式</li><li>装饰模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><p>3.行为型设计模式 </p><ul><li>策略模式</li><li>模板方法模式</li><li>观察者模式</li><li>迭代器模式</li><li>责任链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介模式</li><li>解释器模式</li></ul><p>随着设计模式的发展也涌现出很多新的设计模式：</p><ul><li>规格模式</li><li>对象池模式</li><li>雇工模式</li><li>黑板模式</li><li>空对象模式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Android进阶之光设计模式学习笔记，参考博客：&lt;a href=&quot;https://blog.csdn.net/zhengzhb/article/category/926691/2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
      <category term="Android设计模式" scheme="http://www.xiaohoutongxue.cn/categories/Android%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义View初使用-自定义开关</title>
    <link href="http://www.xiaohoutongxue.cn/2018/04/09/%E8%87%AA%E5%AE%9A%E4%B9%89View/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%80%E5%85%B3/"/>
    <id>http://www.xiaohoutongxue.cn/2018/04/09/自定义View/自定义开关/</id>
    <published>2018-04-09T07:43:28.000Z</published>
    <updated>2018-04-10T04:08:47.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><h5 id="一直觉得自己在自定义View上边花的功夫很少，平时开发中用的最多的也是组合控件要不就是别人的轮子。俗话说得好嘛不想当将军的士兵不是好士兵那么不想自己造轮子的Android开发者怎么会是一个好的开发者呢？我和很多人一样都没有系统去学习过自定义View，本篇博客是我借鉴黑马教程的自定义控件写的不是很难我相信每个人都能看懂。"><a href="#一直觉得自己在自定义View上边花的功夫很少，平时开发中用的最多的也是组合控件要不就是别人的轮子。俗话说得好嘛不想当将军的士兵不是好士兵那么不想自己造轮子的Android开发者怎么会是一个好的开发者呢？我和很多人一样都没有系统去学习过自定义View，本篇博客是我借鉴黑马教程的自定义控件写的不是很难我相信每个人都能看懂。" class="headerlink" title="一直觉得自己在自定义View上边花的功夫很少，平时开发中用的最多的也是组合控件要不就是别人的轮子。俗话说得好嘛不想当将军的士兵不是好士兵那么不想自己造轮子的Android开发者怎么会是一个好的开发者呢？我和很多人一样都没有系统去学习过自定义View，本篇博客是我借鉴黑马教程的自定义控件写的不是很难我相信每个人都能看懂。"></a>一直觉得自己在自定义View上边花的功夫很少，平时开发中用的最多的也是组合控件要不就是别人的轮子。俗话说得好嘛不想当将军的士兵不是好士兵那么不想自己造轮子的Android开发者怎么会是一个好的开发者呢？我和很多人一样都没有系统去学习过自定义View，本篇博客是我借鉴黑马教程的自定义控件写的不是很难我相信每个人都能看懂。</h5></blockquote><p>先上效果图</p><p><img src="http://p6urtncv1.bkt.clouddn.com/img.png" alt=""></p><p>自定义View可以分为三大类</p><ul><li>组合已有控件</li><li>完全自定义View</li><li>继承已有的控件实现扩展功能</li></ul><p>这里呢我们重点讲完全自定义View，在讲解之前我们来快速了解一下Android界面绘制流程：</p><p>​    <img src="http://p6urtncv1.bkt.clouddn.com/3.png" alt=""></p><p>Android界面绘制重写对应方法按照上边依次执行切记这些都是在onResume之后执行，Android界面由View和ViewGroup组成：</p><ol><li><p>View（单纯的控件,如：EditText、Button等）绘制流程</p><p> onMeasure() (在这个方法里指定自己的宽高) -&gt; onDraw() (绘制自己的内容)</p></li><li><p>ViewGroup（如：LinearLayout等）绘制流程</p><p> onMeasure() (指定自己的宽高, 所有子View的宽高)-&gt; onLayout() (摆放所有子View) -&gt; onDraw() (绘制内容)</p></li></ol><h2 id="接下来开始定义我们的View："><a href="#接下来开始定义我们的View：" class="headerlink" title="接下来开始定义我们的View："></a>接下来开始定义我们的View：</h2><ol><li><p>写一个继承View类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchView</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在继承时可以看到有四个构造方法：    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SwitchView(Context context)  用于代码创建控件</span><br><span class="line">SwitchView(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)  用于在xml里使用，可指定自定义属性</span><br><span class="line">SwitchView(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)  用于xml里使用，可指定自定义属性、和样式</span><br><span class="line">SwitchView(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span><br></pre></td></tr></table></figure><p>这里我们只需要使用三个构造方法即可。</p></li><li><p>拷贝包含包名的全路径到xml中并在界面中找到该控件设置对应信息</p><ul><li><p>找到控件</p><p>这个都很简单直接用findViewById就可以直接找到就不多说了</p></li></ul></li></ol><ul><li><p>设置信息</p><p><img src="http://p6urtncv1.bkt.clouddn.com/img.png" alt=""></p><p>上边是我们要实现的效果 可以看出只需要配置三种信息即可：设置背景图片、前景图片和开关状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">switchView.setSwitchBackground(R.drawable.switch_background);</span><br><span class="line">switchView.setSwitchSrc(R.drawable.slide_button);</span><br><span class="line">switchView.setSwitchOpen(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>我们在继承View的类中创建对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置滑块图片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> switch_background</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwitchSrc</span><span class="params">(<span class="keyword">int</span> switch_background)</span> </span>&#123;</span><br><span class="line">       imgSrc = BitmapFactory.decodeResource(getResources(), switch_background);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 设置背景</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> switch_background</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwitchBackground</span><span class="params">(<span class="keyword">int</span> switch_background)</span> </span>&#123;</span><br><span class="line">       imgBg = BitmapFactory.decodeResource(getResources(),switch_background);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwitchOpen</span><span class="params">(<span class="keyword">boolean</span> isOpen)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.isOpen = isOpen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里我们是通过上边我们自己传入的默认开关状态设置滑块位置，left是当前控件左上角坐标，使用背景宽度-滑块宽度刚好就是左上角坐标位置。大家自己也可以看到我们的UI现在画好了，接下来我们来实现触摸反馈。</p></li></ul><ol start="3"><li><p>设置控件的宽度和高度（测量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设置宽度和高度</span></span><br><span class="line">       setMeasuredDimension(imgBg.getWidth(),imgBg.getHeight());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们类中重写onDraw方法（绘制）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制背景</span></span><br><span class="line">canvas.drawBitmap(imgBg,<span class="number">0</span>,<span class="number">0</span>,paint);</span><br><span class="line"><span class="comment">//绘制滑块</span></span><br><span class="line"><span class="keyword">if</span> (isOpen) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//滑块滑动位置大小</span></span><br><span class="line">    <span class="keyword">int</span> left = imgBg.getWidth() - imgSrc.getWidth();</span><br><span class="line">    canvas.drawBitmap(imgSrc, left, <span class="number">0</span>, paint);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    canvas.drawBitmap(imgSrc, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>点击事件（触摸反馈）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (event.getAction())&#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">               <span class="comment">//记录当前位置</span></span><br><span class="line">               switchState = <span class="keyword">true</span>;</span><br><span class="line">               currentX = event.getX();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               currentX = event.getX();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">               switchState = <span class="keyword">false</span>;</span><br><span class="line">               currentX = event.getX();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//重新绘制界面</span></span><br><span class="line">       invalidate();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里我们使用currentX 记录当前位置，并且给了一个boolean值记录了状态，然后在onDraw中重新写一下逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (switchState)&#123;</span><br><span class="line">           canvas.drawBitmap(imgSrc, currentX, <span class="number">0</span>, paint);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (isOpen) &#123;</span><br><span class="line">               <span class="keyword">int</span> left = imgBg.getWidth() - imgSrc.getWidth();</span><br><span class="line">               canvas.drawBitmap(imgSrc, left, <span class="number">0</span>, paint);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               canvas.drawBitmap(imgSrc, <span class="number">0</span>, <span class="number">0</span>, paint);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>这时我们就可以滑动了，这时我们发现滑块可以一直往左边滑动一直往右边滑动，这时我们则需要控制滑块位置避免滑出背景，上述代码第二行上加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据当前用户触摸到的位置画滑块</span></span><br><span class="line"><span class="comment">// 让滑块向左移动自身一半大小的位置</span></span><br><span class="line"><span class="keyword">float</span> newLeft = currentX - slideButtonBitmap.getWidth() / <span class="number">2.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLeft = switchBackgroupBitmap.getWidth() - slideButtonBitmap.getWidth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定滑块范围</span></span><br><span class="line"><span class="keyword">if</span>(newLeft &lt; <span class="number">0</span>)&#123;</span><br><span class="line">newLeft = <span class="number">0</span>; <span class="comment">// 左边范围</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (newLeft &gt; maxLeft) &#123;</span><br><span class="line">newLeft = maxLeft; <span class="comment">// 右边范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.drawBitmap(slideButtonBitmap, newLeft, <span class="number">0</span>, paint);</span><br></pre></td></tr></table></figure><p>控制滑块滑动结束后的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> center = switchBackgroupBitmap.getWidth() / <span class="number">2.0f</span>;</span><br><span class="line"><span class="comment">// 根据当前按下的位置, 和控件中心的位置进行比较. </span></span><br><span class="line"><span class="keyword">boolean</span> state = currentX &gt; center;</span><br><span class="line"><span class="comment">// 如果开关状态变化了, 通知界面. 里边开关状态更新了.</span></span><br><span class="line"><span class="keyword">if</span>(state != mSwitchState &amp;&amp; onSwitchStateUpdateListener != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">// 把最新的boolean, 状态传出去了</span></span><br><span class="line">onSwitchStateUpdateListener.onStateUpdate(state);</span><br><span class="line">&#125;</span><br><span class="line">mSwitchState = state;</span><br></pre></td></tr></table></figure></li><li><p>自定义监听</p><ul><li><p>声明接口对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSwitchUpdateListener</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onSwitchUpdateListener</span><span class="params">(<span class="keyword">boolean</span> state)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>添加设置接口对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OnSwitchUpdateListener onSwitchUpdateListener = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSwitchUpdateListener</span><span class="params">(OnSwitchUpdateListener onSwitchUpdateListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSwitchUpdateListener = onSwitchUpdateListener;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>在适合的位置执行接口方法（这里因为是自己自定义View我们在触摸方法总执行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">     switchState = <span class="keyword">false</span>;</span><br><span class="line">     currentX = event.getX();</span><br><span class="line">     <span class="keyword">float</span> center = imgBg.getWidth() / <span class="number">2.0f</span>;</span><br><span class="line">     <span class="comment">//记录变化</span></span><br><span class="line">     <span class="keyword">boolean</span> state = currentX &gt; center;</span><br><span class="line">     <span class="comment">//设置监听</span></span><br><span class="line">     <span class="keyword">if</span> (isOpen != state &amp;&amp; onSwitchUpdateListener !=<span class="keyword">null</span>) &#123;</span><br><span class="line">      onSwitchUpdateListener.onSwitchUpdateListener(state);</span><br><span class="line">         &#125;</span><br><span class="line">      isOpen = state;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p>界面收到事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">switchView.setOnSwitchUpdateListener(<span class="keyword">new</span> SwitchView.OnSwitchUpdateListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwitchUpdateListener</span><span class="params">(<span class="keyword">boolean</span> state)</span> </span>&#123;</span><br><span class="line">               Log.e(TAG,state+<span class="string">"----&gt;"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自定义属性（通过这个设置我们就可以直接在布局文件中直接赋值了）</p><ul><li><p>创建attrs并在attrs.xml声明节点declare-styleable（参照系统View的attrs）</p><p>属性解释</p><p>|  名称  | 说明 |            例            |<br>| :—-: | :–: | :———————-: |<br>|  name  | 名称 | name=”switch_background” |<br>| format | 类型 |    format=”reference”    |</p><p>format属性说明</p><p>|   名称    |           说明           |<br>| :——-: | :———————-: |<br>| reference | 表示引用，参考某一资源ID |<br>|  string   |          字符串          |<br>|   color   |          颜色值          |<br>| dimension |           尺寸           |<br>|  boolean  |           布尔           |<br>|  integer  |           整型           |<br>|   float   |          浮点数          |<br>| fraction  |          百分数          |<br>|   enum    |           枚举           |<br>|   flag    |        表示位运算        |</p><p>例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"SwitchView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"switch_background"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"switch_src"</span> <span class="attr">format</span>=<span class="string">"reference"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"switch_state"</span> <span class="attr">format</span>=<span class="string">"boolean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在xml配置声明的属性，添加命名空间</p><p>命名空间声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:android="http://schemas.android.com/apk/res/android"</span><br></pre></td></tr></table></figure><p>参照系统格式我总结出格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:自己随意写="http://schemas.android.com/apk/res/项目包名"</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中获取并使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SwitchView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(context, attrs);</span><br><span class="line">       <span class="comment">//声明命名空间</span></span><br><span class="line">String name = <span class="string">"http://schemas.android.com/apk/res/com.example.administrator.customview"</span>;</span><br><span class="line">       isOpen = attrs.getAttributeBooleanValue(name,<span class="string">"switch_state"</span>,<span class="keyword">false</span>);</span><br><span class="line">       setSwitchOpen(isOpen);</span><br><span class="line">       <span class="keyword">int</span> background = attrs.getAttributeResourceValue(name,<span class="string">"switch_background"</span>,-<span class="number">1</span>);</span><br><span class="line">       setSwitchBackground(background);</span><br><span class="line">       <span class="keyword">int</span> src = attrs.getAttributeResourceValue(name,<span class="string">"switch_src"</span>,-<span class="number">1</span>);</span><br><span class="line">       setSwitchSrc(src);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样我们的开关就大功告成啦</p><h5 id="项目地址：-https-github-com-HOUJINZHI-customview-git"><a href="#项目地址：-https-github-com-HOUJINZHI-customview-git" class="headerlink" title="项目地址：    https://github.com/HOUJINZHI/customview.git"></a>项目地址：    <a href="https://github.com/HOUJINZHI/customview.git" target="_blank" rel="noopener">https://github.com/HOUJINZHI/customview.git</a></h5><p>总结：<br>  从上边我们写的看起来也不是很复杂哈，自定义View其实就三个重点测量、绘制和触摸反馈，我的讲解就结束啦，希望通过这篇文章能给你带来帮助。</p></li></ol><blockquote><h4 id="最后献上几篇比较好的自定义View教程"><a href="#最后献上几篇比较好的自定义View教程" class="headerlink" title="最后献上几篇比较好的自定义View教程"></a>最后献上几篇比较好的自定义View教程</h4></blockquote><ul><li><a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">http://www.gcssloop.com/customview/CustomViewIndex</a></li><li><a href="https://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">https://blog.csdn.net/harvic880925/article/details/50995268</a> </li><li><a href="http://hencoder.com" target="_blank" rel="noopener">http://hencoder.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;h5 id=&quot;一直觉得自己在自定义View上边花的功夫很少，平时开发中用的最多的也是组合控件要不就是别人的轮子。俗话说
      
    
    </summary>
    
      <category term="View" scheme="http://www.xiaohoutongxue.cn/categories/View/"/>
    
    
      <category term="自定义View" scheme="http://www.xiaohoutongxue.cn/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>程序员Git必备操作-使用Git上传文件到码云</title>
    <link href="http://www.xiaohoutongxue.cn/2018/04/08/Git/%E7%A8%8B%E5%BA%8F%E5%91%98Git%E5%BF%85%E5%A4%87%E6%93%8D%E4%BD%9C-%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E7%A0%81%E4%BA%91/"/>
    <id>http://www.xiaohoutongxue.cn/2018/04/08/Git/程序员Git必备操作-使用Git上传文件到码云/</id>
    <published>2018-04-08T06:19:31.000Z</published>
    <updated>2018-04-09T08:26:23.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一个程序员，你要学会代码的管理，这是一个最基本的修养，就像是一个剑客的剑谱，代码管理，目前流行的是svn和git，但是很不好的是git如果没有插件的话，很多人都不会用git bash 来实现自己的代码管理，自己不断尝试，今天终于总结出一个很好的方法，供各位剑客参考一下，望尔等使用后，脱离天天来回背电脑的苦逼命运。</p></blockquote><h2 id="一、码云配置"><a href="#一、码云配置" class="headerlink" title="一、码云配置"></a>一、码云配置</h2><h5 id="1-使用自己已有的账号创建一个新项目"><a href="#1-使用自己已有的账号创建一个新项目" class="headerlink" title="1.使用自己已有的账号创建一个新项目"></a>1.使用自己已有的账号创建一个新项目</h5><h5 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2.创建项目"></a>2.创建项目</h5><h2 id="二、Git操作"><a href="#二、Git操作" class="headerlink" title="二、Git操作"></a>二、Git操作</h2><h5 id="1-下载git"><a href="#1-下载git" class="headerlink" title="1.下载git"></a>1.下载git</h5><p>​    网址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a> 选择操作系统对应的版本下载即可</p><h5 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h5><p>​    选择自己要安装的的目录安装即可</p><h5 id="3-配置用户名邮箱"><a href="#3-配置用户名邮箱" class="headerlink" title="3.配置用户名邮箱"></a>3.配置用户名邮箱</h5><p>​    git config –global user.name “用户名”</p><p>​        git config –global user.email “邮箱地址”</p><p>​<br>    <img src="https://i.imgur.com/ge7MgHF.png" alt=""></p><h5 id="4-创建本地厂库"><a href="#4-创建本地厂库" class="headerlink" title="4.创建本地厂库"></a>4.创建本地厂库</h5><p>​    git init 初始化git仓库</p><p><img src="https://i.imgur.com/cH1v9t1.png" alt=""></p><h5 id="5-链接远程仓库"><a href="#5-链接远程仓库" class="headerlink" title="5.链接远程仓库"></a>5.链接远程仓库</h5><p>​     git remote add orgin “你的远程仓库地址”（复制链接后记得加 .git）</p><p><img src="https://i.imgur.com/EzkdDSN.png" alt=""></p><h5 id="6-上传代码到码云"><a href="#6-上传代码到码云" class="headerlink" title="6.上传代码到码云"></a>6.上传代码到码云</h5><p>​          git add .</p><p><img src="https://i.imgur.com/nro8UdD.png" alt=""></p><h5 id="7-添加文件注释"><a href="#7-添加文件注释" class="headerlink" title="7.添加文件注释"></a>7.添加文件注释</h5><p>​      git commit -m ‘第一次添加’</p><p><img src="https://i.imgur.com/Wcwl5sS.png" alt=""></p><h5 id="8-上传代码"><a href="#8-上传代码" class="headerlink" title="8.上传代码"></a>8.上传代码</h5><p>​           git push -u origin master 如果上传失败 则使用 git push -u origin master -f  （强制上传文件）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为一个程序员，你要学会代码的管理，这是一个最基本的修养，就像是一个剑客的剑谱，代码管理，目前流行的是svn和git，但是很不好的是git如果没有插件的话，很多人都不会用git bash 来实现自己的代码管理，自己不断尝试，今天终于总结出一个很好的
      
    
    </summary>
    
      <category term="Git" scheme="http://www.xiaohoutongxue.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.xiaohoutongxue.cn/tags/Git/"/>
    
  </entry>
  
</feed>
